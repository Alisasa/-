''' 
记忆化搜索（本质是动态规划） = 深度优先搜索+记忆

特点：
1. 需要是有返回值的函数
2. 返回值只跟输入的参数有关、和别的无关（时间、第几次调用等其他因素）
3. 参数列表中传入哈希表或者其他用于记录计算结果的数据结构，和系统设计中cache缓存很像

缺点： stackoverflow 不适合解决时间复杂度为O（n）级别的问题
优点：在原code加hash就行，比较简单容易实现 

复杂度：
1.时间复杂度：O（状态总数*计算每个状态的时间耗费）
2.空间复杂度：O（状态总数*计算每个状态的空间耗费+递归深度）

适用题目类型：
1.求可行性：返回可行（True）不可行（False）；大问题=小问题or小问题or... 只要有一个小问题可行 就True;代码for小问题 if dp[小问题] == true then break的形式实现
2.求方案数：返回方案数；dp[大问题]=求和（dp[小问题1]，dp[小问题2]，...）
3.求最值：返回最优值的类型；dp[大问题] = min/max{dp[小问题1]，dp[小问题2]，...}
 
其他：
VS 分治法 
同：都是算法思想 都不是算法
不同：分完之后有没有交集 有交集=>动态规划 没有交集=>分治法
'''
